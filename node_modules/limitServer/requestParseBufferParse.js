"use strict";

const fs = require('fs');
const limit = require('limit');
const serverConfig = require(`${limit.rootPath}/config`);

// 解析请求
class RequestParseBufferParse {
	constructor(request, boundary){
		let me = this;
		let state = me.state = {};
		let bufferList = state.bufferList = [];	// 存放所有的buffer
		state.bufferRealList = []; // 存放解析后的buffer
		state.resultList = []; // 最终的
		state.isDoingParse = false; // 解析的开关
		state.guid = -1; //节点
		let boundaryNew = me.boundaryNew = Buffer.concat([new Buffer('--'), new Buffer(boundary)]);
		me.boundaryLeg = boundaryNew.length;
		return new Promise((resolve, reject) => {
			request.on('data', (buffer) => {
				bufferList.push(buffer);
				if( !state.isDoingParse ){
					me.getBuffer();
				};
			}).on('end', () => {
				me.eachBuffer();
				resolve( state.resultList );
			});
		});
	}
	getBuffer(){
		let me = this;
		let target = null;
		let boundaryNew = me.boundaryNew;
		let boundaryLeg = me.boundaryLeg;
		let state = me.state;
		let bufferList = state.bufferList;
		let bufferRealList = state.bufferRealList;
		state.isDoingParse = true;
		while( target = bufferList.pop() ){
			for(let i = 0; i < target.length; i++){
				// 寻找节点
				let tempBuf = target.slice(i, i + boundaryLeg);
				if( tempBuf.equals(boundaryNew) ){
					state.guid++;
					i += boundaryLeg;
				};
				// 入栈
				let guid = state.guid;
				if( guid !== -1 ){
					let targetArr = bufferRealList[guid];
					if( !targetArr ){
						targetArr = bufferRealList[guid] = [];
					};
					targetArr.push(target[i]);
				};
			};
			me.eachBuffer();
		};
		state.isDoingParse = false;	
	}
	eachBuffer(){
		let me = this;
		let state = me.state;
		let bufferRealList = state.bufferRealList;
		let resultList = state.resultList;
		let index = bufferRealList.length - 1;
		// 如果bufferList位置比较小的就表明解析完成否者解析中
		// 循环遍历所有的bufferList
		// 然后解析出fileName字段
		// 如果存在fileName字段 格式化数组 
		bufferRealList.forEach((val, key) => {
			if( val.status !== 'getted' ){
				val.status = 'getting';
				me.parseBuffer(val, key);
				if( key < index ){
					val.status = 'getted';
					// 关闭文件流
					val.writeStream && val.writeStream.end();
				};
			};
		});
	}
	createReadStream(fileBuffer, main){
		let me = this;
		if( main.writeStream ){
			main.writeStream.write(fileBuffer);
			main.splice(0, main.length - 2);
		};
	}
	createWriteStream(filename, main){
		let me = this;
		let writeStream = fs.createWriteStream(`${serverConfig.filePath}${filename}`);
		main.writeStream = writeStream;
	}
	parseBuffer(bufferArray, key){
		let me = this;
		let state = me.state;
		let resultList = state.resultList;
		// 已经解析的是文件
		if( bufferArray.filename ){
			me.createReadStream( new Buffer( bufferArray.slice(0, -2) ), bufferArray );
		}else{
			let result = me.parseKey(bufferArray);
			if( result.name ){
				resultList[key] = result;
			};
			// 如果存在文件的情况
			if( result.file ){
				bufferArray.filename = result.val;
				bufferArray.files = [];
				// 创建写入流
				me.createWriteStream(result.val, bufferArray);
				// 保留最后两个 其余的删除
				me.createReadStream( result.file, bufferArray );
				delete result.file;
			};
		};
	}
	parseKey(buffer){
		let buf = new Buffer('\r\n\r\n');
		let leg = buf.length;
		let offset = 0;
		buffer = new Buffer(buffer);
		for(let i = 0; i < buffer.length; i++){
			let tempBuf = buffer.slice(i, i + leg);
			if( tempBuf.equals(buf) ){
				offset = i;
				break;
			};
		};
		let key = buffer.slice(0, offset).toString();
		let val = buffer.slice(offset + leg, buffer.length - 2);
		// 获取name
		let matchNameKey = key.match(/; name="(.*?)"/);
		let name;
		if( matchNameKey ){
			name = matchNameKey[1];
		}else{
			name = '';
		};
		// 获取filename
		let matchFileNameKey = key.match(/; filename="(.*?)"/);
		let filename;
		if( matchFileNameKey ){
			filename = matchFileNameKey[1];
		};
		let rtv = {name, val};
		if( filename ){
			rtv.val = rtv.originFilename = filename;
			rtv.file = val;
		}else{
			rtv.val = rtv.val.toString();
		};
		return rtv;
	}
};

module.exports = RequestParseBufferParse;








