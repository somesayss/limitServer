"use strict";

// 依赖
const limit = require('limit');
const EventEmitter = require('events');

// 依赖
const ServerSocketSender = require('./serverSocketSender');
const ServerSocketParseBuffer = require('./serverSocketParseBuffer');

class ServerSocket extends EventEmitter {
	constructor(socket){
    	super();
    	let me = this;
    	me.state = {
    		PONG_CODE: 0,
    		LOOG_TIME: 1 * 60 * 1000, // 长心跳1分钟
    		SHORT_TIME: 10000, // 短心跳10秒
    		TIME_ID: null
    	};
    	me.socket = socket;
    	me.bindEvent();
    	me.creatParseBuffer();
    	me.loopPing();
	}
	bindEvent(){
		let me = this;
		let socket = me.socket;
		['data', 'end'].forEach((val) => {
			me.on( val, limit.cb(me[`onSC${val}`]) );
			socket.on( val, (...args) => me.emit.apply(me, [val, ...args]) );
		});
	}
	onSCdata(buffer){
		console.log('data0', buffer);
		let me = this;
		let PB = me.PB;
		me.loopPing();
		PB.add(buffer);
	}
	creatParseBuffer(){
		let me = this;
		me.PB = new ServerSocketParseBuffer();
		['message', 'close', 'pong'].forEach((val) => {
			me.on( val, limit.cb(me[`onPB${val}`]) );
			me.PB.on( val, (...args) => me.emit.apply(me, [val, ...args]) );
		});
	}
	onPBclose(){
		let me = this;
		me.destroy();
	}
	onPBpong(){
		let me = this;
		let {state} = me;
		state.PONG_CODE = 0;
		me.loopPing();
	}
	loopPing(){
		let me = this;
		let {state} = me;
		let time = state.LOOG_TIME;
		clearTimeout(state.TIME_ID);
		if( state.PONG_CODE ){
			time = state.SHORT_TIME;
		};
		state.TIME_ID = setTimeout(() => {
			me.ping(() => {
				if( ++state.PONG_CODE > 3 ){
					me.emit('close');
				}else{
					me.loopPing();
				};
			});
		}, time);
	}
	ping(cb){
		let me = this;
		let {socket} = me;
		socket.write( new ServerSocketSender('', {OP_CODE: 9}).getBuffer(), cb);
	}
	close(){
		let me = this;
		let {socket} = me;
		socket.write( new ServerSocketSender('', {OP_CODE: 8}).getBuffer(), () => {
			me.emit('close');
		});
	}
	send(message){
		let me = this;
		let {socket} = me;
		socket.write( new ServerSocketSender(message).getBuffer() );
	}
	destroy(){
		let me = this;
		let {socket, state} = me;
		clearTimeout(state.TIME_ID);
		me.PB.destroy();
		me.removeAllListeners();
	}
};

module.exports = ServerSocket;





























