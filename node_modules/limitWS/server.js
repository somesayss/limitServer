"use strict";

// 依赖
const http = require('http');
const limit = require('limit');
const crypto = require('crypto');
const EventEmitter = require('events');

// 依赖
const ServerSocket = require('./serverSocket');

// 常量
const GUID = '258EAFA5-E914-47DA-95CA-C5AB0DC85B11';


class Server extends EventEmitter {
	constructor(props){
    	super();
    	let me = this;
    	me.state = {
    		port: '8181',
    		ip: '0.0.0.0'
    	};
    	Object.assign(me.state, props);
    	me.createServer();
    	me.bindEvent();
	}
	createServer(){
		let me = this;
		let state = me.state;
		let server = me.server = http.createServer().listen(state.port, state.ip);
		// server.allowHalfOpen = false; // 不清楚用作
	}
	bindEvent(){
		let me = this;
		let server = me.server;
		['listening', 'error', 'upgrade'].forEach((val) => {
			me.on( val, limit.cb(me[`on${val}`]) );
			server.on( val, (...args) => me.emit.apply(me, [val, ...args]) );
		});
	}
	onupgrade(req, socket, head){
		let me = this;
		let {headers, method} = req;
		me.method = method;
		me.socket = socket;
		me.headers = headers;
		if( me.checkHeader() ){
			me.successShake();
			me.emit('connection', new ServerSocket(socket));
		}else{
			me.errorShake(400);
		};
	}
	checkHeader(){
		let me = this;
		let { headers, method } = me;
		let { connection, upgrade } = headers;
		let websocketKey = headers['sec-websocket-key'];
		let websocketVersion = headers['sec-websocket-version'];
		// 必须是get
		if( method !== 'GET' ){
			return false;
		};
		// 必须字段匹配
		if( connection !== 'Upgrade' ){
			return false;
		}
		// 必须字段匹配
		if( upgrade !== 'websocket' ){
			return false;
		};
		// 版本匹配
		if( websocketVersion !== '13' ){
			return false;
		};
		// 存在Key
		if( !websocketKey ){
			return false;
		};
		return true;
	}
	successShake(){
		let me = this;
		let {socket, headers} = me;
		let key = crypto.createHash('sha1')
	     	.update(headers['sec-websocket-key'] + GUID, 'binary')
			.digest('base64');
		let writeHeader = [
			`HTTP/1.1 101 Switching Protocols`,
			`Upgrade: websocket`,
			`Connection: Upgrade`,
			`Sec-WebSocket-Accept: ${key}`
		];
		let EH = me.setExtensionsHeader();
		if( EH ){
			writeHeader.push(EH);
		};
		writeHeader.push('\r\n');
		socket.write(writeHeader.join('\r\n'));
	}
	errorShake(code){
		let me = this;
		let {socket} = me;
		let writeHeader = [
			`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}`,
			`Connection: close`,
			`Content-type: text/html`,
			`Content-Length: ${Buffer.byteLength( http.STATUS_CODES[code] )}`,
		    `\r\n`,
		    `${http.STATUS_CODES[code]}`
		];
		socket.write(writeHeader.join('\r\n'));
	}
	setExtensionsHeader(){
		let me = this;
		let {headers} = me;
		let extensions = headers['sec-websocket-extensions'];
		if( extensions ){
			return 'Sec-WebSocket-Extensions: permessage-deflate';
		};
	}
};

module.exports = Server;





























