"use strict";

// 依赖
const zlib = require('zlib');
const limit = require('limit');
const EventEmitter = require('events');

// 变量
const arrayPush = Array.prototype.push;
const BLANK_BUFFER = new Buffer([0x00, 0x00, 0xff, 0xff]);

let guid = 0;

class ServerSocketParseBuffer extends EventEmitter {
	constructor(buffer){
    	super();
    	let me = this;
    	me.state = {
    		OP_CODE: null, //操作码，0为继续，1为文本，2为二进制，8为关闭，9为ping，10为pong
    		LEG_CODE: null, //长度码，0，1，2
    		LENGTH: null, //数据长度
    		FIN_CODE: null, //掩码，0为继续，1位开始
    		RSV_CODE: null, //RSV码，作为扩展
    		MASK_CODE: null //密钥
    	};
    	me.originBufferList = [];
    	me.bufferList = [];
    	me.guid = guid++;
	}
	add(buffer){
		let me = this;
		let state = me.state;
		me.originBufferList.push(buffer);
		if( state.FIN_CODE === null ){
			me.getCode();
		}else{
			me.loopData();
		};
	}
	setBufferList(){
		let me = this;
		let {state, bufferList, originBufferList} = me;
		let legArr = [6, 8, 14];
		let FB = originBufferList.shift();
		if( FB ){
			arrayPush.apply( bufferList, Array.from( FB.slice(legArr[state.LEG_CODE]) ) );
		};
		me.getVal();
	}
	loopData(){
		let me = this;
		let {originBufferList, bufferList, state} = me;
		let FB = originBufferList.shift();
		if( FB ){
			arrayPush.apply( bufferList, Array.from( FB ) );
		};
		me.getVal();
	}
	getVal(){
		let me = this;
		let {state, bufferList} = me;
		if( bufferList.length === state.LENGTH ){
			let MASK_CODE = state.MASK_CODE;
			if( MASK_CODE ){
				bufferList = bufferList.map((val, i) => {
					return val ^ MASK_CODE[i%4];
				});
			};
			let outMethed = ['outMessage', 'outZlibMessage'];
			// 如果是RSV
			me[ outMethed[state.RSV_CODE] ]( new Buffer(bufferList) );
		};
	}
	// RSV为0时候的普通输出
	outMessage(buffer){
		let me = this;
		me.emit( 'message', buffer.toString() );
		me.resetState();
	}
	// RSV为1时候的解密输出
	outZlibMessage(buffer){
		let me = this;
		let inflate = me.inflate;
		if( !inflate ){
			inflate = me.inflate = zlib.createInflateRaw();
		};
		inflate.on('data', (data) => {
			me.emit( 'message', data.toString() );
			me.resetState();
		});
		inflate.write(buffer);
		inflate.write(BLANK_BUFFER);
		inflate.flush(() => {
			inflate.removeAllListeners();
		});
	}
	// 关闭
	closeSocket(){
		let me = this;
		me.emit( 'close' );
	}
	// 心跳pong
	pongSocket(){
		let me = this;
		me.emit( 'pong' );
		me.resetState();

	}
	// 路由code
	routerCode(){
		let me = this;
		let {state} = me;
		let router = {
			'1': 'setBufferList', //字符串处理
			'8': 'closeSocket',
			'10': 'pongSocket'
		};
		me[router[state.OP_CODE]]();
	}
	getCode(){
		let me = this;
		me.keyBuf = me.originBufferList[0];
		me.getOpCode().getLength().getFinCode().getRsvCode().getMaskCode();
		me.routerCode();
	}
	getOpCode(){
		let me = this;
		let {state, keyBuf} = me;
		let code = keyBuf[0];
		state.OP_CODE = code & 0x0f;
		return me;
	}
	getLength(){
		let me = this;
		let {state, keyBuf} = me;
		let code = keyBuf[1];
		// 规则比价复杂
		let leg = code & 127;;
		// 如果小于125
		if( leg <= 125 ){
			state.LEG_CODE = 0;
			state.LENGTH = leg;
		}else if( leg === 126 ){
			state.LEG_CODE = 1;
			state.LENGTH = me.getLengthByBuf(4);
		}else{
			state.LEG_CODE = 2;
			state.LENGTH = me.getLengthByBuf(10);
		};
		return me;
	}
	getLengthByBuf(leg){
		let me = this;
		let {keyBuf} = me;
		let str = '';
		for(let i = 2; i < leg; i++){
			str += limit.padStart( keyBuf[i].toString(2), 8, '0' );
		};
		return parseInt(str, 2);
	}
	getFinCode(){
		let me = this;
		let {state, keyBuf} = me;
		let code = keyBuf[0];
		state.FIN_CODE = code >> 7;
		return me;
	}
	// RSV版本，扩展，如果是0是未压缩，1是压缩，2未知，3未知
	getRsvCode(){
		let me = this;
		let {state, keyBuf} = me;
		let code = keyBuf[0];
		state.RSV_CODE = ((code & 64) >> 6) + ((code & 32) >> 5) + ((code & 16) >> 4); 
		return me;
	}
	// 密钥
	getMaskCode(){
		let me = this;
		let {state, keyBuf} = me;
		let code = keyBuf[1];
		let isMask = code >> 7;
		if( isMask === 1 ){
			let legArr = [[2, 6], [4, 8], [10, 14]];
			state.MASK_CODE = Array.from( keyBuf.slice.apply(keyBuf, legArr[state.LEG_CODE]) );
		};
		return me;
	}
	// 重置
	resetState(){
		let me = this;
		let {state, originBufferList, bufferList} = me;
		limit.each(state, (val, key) => {
			state[key] = null;
		});
		bufferList.length = 0;
		originBufferList.length = 0;
	}
	// 销毁
	destroy(){
		let me = this;
		me.inflate && me.inflate.close();
		me.removeAllListeners();
	}
};

module.exports = ServerSocketParseBuffer;















